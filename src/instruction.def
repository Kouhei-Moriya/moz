DEF(Nop)
{
    /* do nothing */
}
DEF(Fail)
{
L_fail:;
    // asm volatile("int3");
    // FAIL();
    long saved_, ast_tx_;
    moz_inst_t *jump_;
    char *pos_;
    POP_FRAME(pos_, jump_, ast_tx_, saved_);
    if (pos_ < CURRENT) {
        HEAD = (HEAD < CURRENT) ? CURRENT : HEAD;
        CURRENT = pos_;
    }
    ast_rollback_tx(AST_MACHINE_GET(), ast_tx_);
    symtable_rollback(SYMTABLE_GET(), saved_);
#ifdef MOZVM_DEBUG_NTERM
    // fprintf(stderr, "%-8s fail  SP=%p FP=%p jump=%p\n", runtime->nterms[nterm_id], SP, FP, jump_);
#endif
    PC = jump_;

}
DEF(Alt, int failjump)
{
    AstMachine *ast = AST_MACHINE_GET();
    symtable_t *tbl = SYMTABLE_GET();
    // asm volatile("int3");
    PUSH_FRAME(CURRENT, PC + failjump, ast_save_tx(ast), symtable_savepoint(tbl));
#ifdef MOZVM_DEBUG_NTERM
    // fprintf(stderr, "%-8s alt   SP=%p FP=%p\n", runtime->nterms[nterm_id], SP, FP);
#endif
}
DEF(Succ)
{
    long saved, ast_tx;
    char *pos;
    moz_inst_t *jump;
    POP_FRAME(pos, jump, ast_tx, saved);
    (void)saved; (void)ast_tx; (void)jump; (void)pos;
}
DEF(Jump, int jump)
{
    JUMP(jump);
}
// DEF(Call, int nterm, int jump)
DEF(Call, int jump)
{
#ifdef MOZVM_DEBUG_NTERM
    PUSH(nterm_id);
    nterm_id = nterm;
#endif
    PUSH(PC);
#ifdef MOZVM_DEBUG_NTERM
    // fprintf(stderr, "%-8s call  SP=%p FP=%p next=%p, jump=%p\n", runtime->nterms[nterm_id], SP, FP, PC, PC + jump);
#else
    // (void)nterm;
#endif
    JUMP(jump);
}
DEF(Ret)
{
    moz_inst_t *next = (moz_inst_t *)POP();
#ifdef MOZVM_DEBUG_NTERM
    // fprintf(stderr, "%-8s ret   SP=%p FP=%p next=%p\n", runtime->nterms[nterm_id], SP, FP, next);
    nterm_id = POP();
#endif
    // asm volatile("int3");
    PC = next;
}
DEF(Pos)
{
    PUSH(CURRENT);
}
DEF(Back)
{
    CURRENT = (char *)POP();
}
DEF(Skip)
{
    AstMachine *ast = AST_MACHINE_GET();
    symtable_t *tbl = SYMTABLE_GET();

    long *saved, *ast_tx;
    moz_inst_t **jump;
    char **pos;
    PEEK_FRAME(pos, jump, ast_tx, saved);
#if 0
#ifdef MOZVM_DEBUG_NTERM
    fprintf(stderr, "%-8s skip  SP=%p FP=%p\n", runtime->nterms[nterm_id], SP, FP);
#endif
    fprintf(stderr, "peek %ld\n", *(FP+0));
    fprintf(stderr, "peek %ld\n", *(FP+1));
    fprintf(stderr, "peek %ld\n", *(FP+2));
    fprintf(stderr, "peek %ld\n", *(FP+3));
    fprintf(stderr, "peek %ld\n", *(FP+4));
#endif
    if (*pos == CURRENT) {
        FAIL();
    }
    *pos = CURRENT;
    *ast_tx = ast_save_tx(ast);
    *saved  = symtable_savepoint(tbl);
    (void)jump;
}
DEF(Byte, uint8_t ch)
{
    if (*CURRENT != ch) {
        FAIL();
    }
    CONSUME();
}
DEF(Any)
{
    if (EOS()) {
        FAIL();
    }
    CONSUME();
}
DEF(Str, STRING_t strId)
{
    char *str = STRING_GET_IMPL(runtime, strId);
    unsigned len = pstring_length(str);
    if (pstring_starts_with(CURRENT, str, len) == 0) {
        FAIL();
    }
    CONSUME_N(len);
}
DEF(Set, BITSET_t setId)
{
    bitset_t *set = BITSET_GET_IMPL(runtime, setId);
    if (!bitset_get(set, *CURRENT)) {
        FAIL();
    }
    CONSUME();
}
DEF(NByte, uint8_t ch)
{
    if (*CURRENT == ch) {
        FAIL();
    }
}
DEF(NAny)
{
    if (!EOS()) {
        FAIL();
    }

}
DEF(NStr, STRING_t strId)
{
    char *str = STRING_GET_IMPL(runtime, strId);
    unsigned len = pstring_length(str);
    if (pstring_starts_with(CURRENT, str, len) == 1) {
        FAIL();
    }
}
DEF(NSet, BITSET_t setId)
{
    bitset_t *set = BITSET_GET_IMPL(runtime, setId);
    if (bitset_get(set, *CURRENT)) {
        FAIL();
    }
}
DEF(OByte, uint8_t ch)
{
    if (*CURRENT == ch) {
        CONSUME();
    }
}
DEF(OAny)
{
    /* not implemented */
    ABORT();
}
DEF(OStr, STRING_t strId)
{
    char *str = STRING_GET_IMPL(runtime, strId);
    unsigned len = pstring_length(str);
    if (pstring_starts_with(CURRENT, str, len) == 1) {
        CONSUME_N(len);
    }
}
DEF(OSet, BITSET_t setId)
{
    bitset_t *set = BITSET_GET_IMPL(runtime, setId);
    if (bitset_get(set, *CURRENT)) {
        CONSUME();
    }
}
DEF(RByte, uint8_t ch)
{
    while (*CURRENT == ch) {
        CONSUME();
    }
}
DEF(RAny)
{
    /* not implemented */
    ABORT();
}
DEF(RStr, STRING_t strId)
{
    char *str = STRING_GET_IMPL(runtime, strId);
    unsigned len = pstring_length(str);
    while (pstring_starts_with(CURRENT, str, len) == 1) {
        CONSUME_N(len);
    }
}
DEF(RSet, BITSET_t setId)
{
    bitset_t *set = BITSET_GET_IMPL(runtime, setId);
    while (bitset_get(set, *CURRENT)) {
        CONSUME();
    }
}
DEF(Consume, int shift)
{
    CONSUME_N(shift);
}
DEF(First, JMPTBL_t tblId)
{
    int *jmpTable = JMPTBL_GET_IMPL(runtime, tblId);
    int jump = jmpTable[(unsigned)*CURRENT];
    // asm volatile("int3");
    JUMP(jump);
}
DEF(Lookup, uint8_t state, uint16_t memoId, int skip)
{
    MemoEntry_t *entry = memo_get(MEMO_GET(), CURRENT, memoId, state);
    if (entry) {
        if (entry->failed) {
            FAIL();
        }
        CONSUME_N(entry->consumed);
        JUMP(skip);
    }
}
DEF(Memo, uint8_t state, uint16_t memoId)
{
    long saved, ast_tx;
    moz_inst_t *jump;
    char *pos;
    POP_FRAME(pos, jump, ast_tx, saved);
    long length = CURRENT - pos;
    memo_set(MEMO_GET(), pos, memoId, NULL, length, state);
#ifdef MOZVM_DEBUG_NTERM
    // fprintf(stderr, "%-8s memo  SP=%p FP=%p\n", runtime->nterms[nterm_id], SP, FP);
#endif
    (void)saved; (void)ast_tx; (void)jump;
}
DEF(MemoFail, uint8_t state, uint16_t memoId)
{
    memo_fail(MEMO_GET(), CURRENT, memoId);
    FAIL();
    (void)state; // FIXME MemoFail needs state???
}
DEF(TPush)
{
    AstMachine *ast = AST_MACHINE_GET();
    asm volatile("int3");
    ast_log_push(ast);
}
DEF(TPop, int8_t index)
{
    AstMachine *ast = AST_MACHINE_GET();
    asm volatile("int3");
    ast_log_pop(ast, index);
}
DEF(TLeftFold, uint8_t shift)
{
    AstMachine *ast = AST_MACHINE_GET();
    ast_log_swap(ast, CURRENT + shift);
}
DEF(TNew, uint8_t shift)
{
    AstMachine *ast = AST_MACHINE_GET();
    ast_log_new(ast, CURRENT + shift);
}
DEF(TCapture, uint8_t shift)
{
    AstMachine *ast = AST_MACHINE_GET();
    ast_log_capture(ast, CURRENT + shift);
}
DEF(TTag, TAG_t tagId)
{
    tag_t *tag = TAG_GET_IMPL(runtime, tagId);
    AstMachine *ast = AST_MACHINE_GET();
    ast_log_tag(ast, tag);
}
DEF(TReplace, STRING_t strId)
{
    char *str = STRING_GET_IMPL(runtime, strId);
    AstMachine *ast = AST_MACHINE_GET();
    ast_log_replace(ast, str);
}
DEF(TStart)
{
    AstMachine *ast = AST_MACHINE_GET();
    PUSH(ast_save_tx(ast));
}
DEF(TCommit, int8_t index)
{
    long tx = POP();
    AstMachine *ast = AST_MACHINE_GET();
    ast_commit_tx(ast, index, tx);
}
DEF(TAbort)
{
    /* not implemented */
    ABORT();
}
DEF(TLookup, int8_t index, uint8_t state, uint16_t memoId, int skip)
{
    AstMachine *ast = AST_MACHINE_GET();
    MemoEntry_t *entry = memo_get(MEMO_GET(), CURRENT, memoId, state);
    if (entry) {
        if (entry->failed) {
            memo_failhit();
            FAIL();
        }
        memo_hit();
        CONSUME_N(entry->consumed);
        ast_log_link(ast, index, entry->result);
        JUMP(skip);
    }
    memo_miss();
}
DEF(TMemo, uint8_t state, uint16_t memoId)
{
    AstMachine *ast = AST_MACHINE_GET();
    long length;
    long saved, ast_tx;
    moz_inst_t *jump;
    char *pos;
    Node node;
    POP_FRAME(pos, jump, ast_tx, saved);
    length = CURRENT - pos;
    node = ast_get_last_linked_node(ast);
    memo_set(MEMO_GET(), pos, memoId, node, length, state);
#ifdef MOZVM_DEBUG_NTERM
    // fprintf(stderr, "%-8s tmemo SP=%p FP=%p\n", runtime->nterms[nterm_id], SP, FP);
#endif
    (void)saved; (void)ast_tx; (void)jump;
}
DEF(SOpen)
{
    symtable_t *tbl = SYMTABLE_GET();
    PUSH(symtable_savepoint(tbl));
}
DEF(SClose)
{
    symtable_t *tbl = SYMTABLE_GET();
    long saved = POP();
    symtable_rollback(tbl, saved);
}
DEF(SMask, TAG_t tagId)
{
    symtable_t *tbl = SYMTABLE_GET();
    tag_t *tableName = TAG_GET_IMPL(runtime, tagId);
    PUSH(symtable_savepoint(tbl));
    symtable_add_symbol_mask(tbl, tableName);
}
DEF(SDef, TAG_t tagId)
{
    symtable_t *tbl = SYMTABLE_GET();
    tag_t *tableName = TAG_GET_IMPL(runtime, tagId);
    token_t captured;
    token_init(&captured, (char *)POP(), CURRENT);
    symtable_add_symbol(tbl, tableName, &captured);
}
DEF(SIsDef)
{
    /* not implemented */
    ABORT();
}
DEF(SExists, TAG_t tagId)
{
    symtable_t *tbl = SYMTABLE_GET();
    tag_t *tableName = TAG_GET_IMPL(runtime, tagId);
    if (!symtable_has_symbol(tbl, tableName)) {
        FAIL();
    }
}
DEF(SMatch, TAG_t tagId)
{
    symtable_t *tbl = SYMTABLE_GET();
    tag_t *tableName = TAG_GET_IMPL(runtime, tagId);
    token_t t;
    if (symtable_get_symbol(tbl, tableName, &t)) {
        if (token_equal_string(&t, CURRENT)) {
            CONSUME_N(token_length(&t));
            NEXT();
        }
    }
    FAIL();
}
DEF(SIs, TAG_t tagId)
{
    symtable_t *tbl = SYMTABLE_GET();
    tag_t *tableName = TAG_GET_IMPL(runtime, tagId);
    token_t t;
    if (symtable_get_symbol(tbl, tableName, &t)) {
        token_t captured;
        token_init(&captured, (char *)POP(), CURRENT);
        if (token_equal(&t, &captured)) {
            CONSUME_N(token_length(&t));
            NEXT();
        }
    }
    FAIL();
}
DEF(SIsa, TAG_t tagId)
{
    symtable_t *tbl = SYMTABLE_GET();
    token_t captured;
    tag_t *tableName = TAG_GET_IMPL(runtime, tagId);
    token_init(&captured, (char *)POP(), CURRENT);
    if (!symtable_contains(tbl, tableName, &captured)) {
        FAIL();
    }
    CONSUME_N(token_length(&captured));
}
DEF(SDefNum)
{
    /* not implemented */
    ABORT();
}
DEF(SCount)
{
    /* not implemented */
    ABORT();
}
DEF(Exit)
{
    // asm volatile("int3");
    // TODO();
    return 0;
}
DEF(Label)
{
    /* do nothing */
#ifdef MOZVM_DEBUG_NTERM
    nterm_id = label;
#endif
    // fprintf(stderr, "label %d\n", label);
}
